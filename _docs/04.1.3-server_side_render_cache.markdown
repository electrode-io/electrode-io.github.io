---
title:  "Server Side Render Caching + Profiling"
permalink: docs/server_side_render_cache.html
toplevel: "Stand Alone Modules"
---

Optimize React SSR with profiling and component caching. The
[electrode-react-ssr-caching] module supports profiling React Server Side Rendering time
to enable component caching to help you speed up Server Side Rendering of your components.

[electrode-react-ssr-caching] module can be used a *standalone* module and is *agnostic* of
your web-server framework. In this tutorial we will demonstrate how to use this module in Electrode, Express.js and Hapi.js applications.

{% include module_usage.md moduleId="electrode-react-ssr-caching" express_react_redux=true hapi_react_redux=true %}

#### Profiling

You can use this module to inspect the time each component took to render.

```js
import SSRCaching from "electrode-react-ssr-caching";
import { renderToString } from "react-dom/server";
import MyComponent from "mycomponent";

// First you should render your component in
// a loop to prime the JS engine (i.e: V8 for NodeJS)
for( let i = 0; i < 10; i ++ ) {
    renderToString(<MyComponent />);
}

SSRCaching.clearProfileData();
SSRCaching.enableProfiling();
const html = renderToString(<MyComponent />);
SSRCaching.enableProfiling(false);
console.log(JSON.stringify(SSRCaching.profileData, null, 2));
```

#### Caching

Once you've determined the most expensive components with profiling, you can enable the component caching in this module to speed up SSR performance.

The basic steps to enabling caching are:

```js
import SSRCaching from "electrode-react-ssr-caching";

SSRCaching.enableCaching();
SSRCaching.setCachingConfig(cacheConfig);
```

Where `cacheConfig` contains information on what component to apply caching.  See below for details.

##### cacheConfig

SSR component caching was first demonstrated in [Sasha Aickin's talk].

His demo requires each component to provide a function for generating the cache key.

Here we implemented two cache key generation strategies: `simple` and `template`.

You are required to pass in the `cacheConfig` to tell this module what component to apply caching.

For example:

```js
const cacheConfig = {
  components: {
    "Component1": {
      strategy: "simple",
      enable: true
    },
    "Component2": {
      strategy: "template",
      enable: true
    }
  }
}

SSRCaching.setCachingConfig(cacheConfig);
```

#### Caching Strategies

##### simple

The `simple` caching strategy is basically doing a `JSON.stringify` on the component's props.  You can also specify a callback in `cacheConfig` to return the key.

For example:

```js
const cacheConfig = {
  components: {
    Component1: {
      strategy: "simple",
      enable: true,
      genCacheKey: (props) => JSON.stringify(props)
    }
  }
};
```

This strategy is not very flexible.  You need a cache entry for each different props.  However it requires very little processing time.

##### template

The `template` caching strategy is more complex but flexible.  

The idea is akin to generating logic-less handlebars templates from your React components and then use string Replace to process the template with different props.

If you have this component:

```js
class Hello extends Component {
  render() {
    return <div>Hello, {this.props.name}.  {this.props.message}</div>
  }
}
```


And you render it with props:

```js
const props = { name: "Bob", message: "How're you?" }
```

You get back HTML string:

```html
<div>Hello, <span>Bob</span>.  <span>How&#x27;re you?</span></div>
```

Now if you replace values in props with tokens, and you remember that `@0@` refers to `props.name` and `@1@` refers to `props.message`:

```js
const tokenProps = { name: "@0@", message: "@1@" }
```

You get back HTML string that could be akin to a handlebars template:

```html
<div>Hello, <span>@0@</span>.  <span>@1@</span></div>
```

We cache this template html using the tokenized props as cache key.  When we need to render the same component with a different props later, we can just lookup the template from cache and use string replace to apply the values:

```js
cachedTemplateHtml.replace( /@0@/g, props.name ).replace( /@1@/g, props.message );
```

That's the gist of the template strategy.  Of course there are many small details such as handling the encoding of special characters, preserving props that can't be tokenized, avoiding tokenizing non-string props, or preserving `data-reactid` and `data-react-checksum`.

To specify a component to be cached with the `template` strategy:

```js
const cacheConfig = {
    components: {
        Hello: {
            strategy: "template",
            enable: true,
            preserveKeys: [ "key1", "key2" ],
            preserveEmptyKeys: [ "key3", "key4" ],
            ignoreKeys: [ "key5", "key6" ],
            whiteListNonStringKeys: [ "key7", "key8" ]
        }
    }
};
```

   - `preserveKeys` - List of keys that should not be tokenized.
   - `preserveEmptyKeys` - List of keys that should not be tokenized if they are empty string `""`
   - `ignoreKeys` - List of keys that should be completely ignored as part of the template cache key.
   - `whiteListNonStringKeys` - List of non-string keys that should be tokenized.

# API

### [`enableProfiling(flag)`](#enableprofilingflag)

Enable profiling according to flag

   - `undefined` or `true` -  enable profiling
   - `false` - disable profiling

### [`enableCaching(flag)`](#enablecachingflag)

Enable cache according to flag

   - `undefined` or `true` - enable caching
   - `false` - disable caching

### [`enableCachingDebug(flag)`](#enablecachingdebugflag)

Enable cache debugging according to flag.

> Caching must be enabled for this to have any effect.

   - `undefined` or `true` - enable cache debugging
   - `false` - disable cache debugging

### [`setCachingConfig(config)`](#setcachingconfigconfig)

Set caching config to `config`.

### [`stripUrlProtocol(flag)`](#stripurlprotocolflag)

Remove `http:` or `https:` from prop values that are URLs according to flag.

> Caching must be enabled for this to have any effect.

   - `undefined` or `true` - strip URL protocol
   - `false` - don't strip

### [`shouldHashKeys(flag, [hashFn])`](#shouldhashkeysflaghashfn)

Set whether the `template` strategy should hash the cache key and use that instead.

> Caching must be enabled for this to have any effect.

  - `flag`
    - `undefined` or `true` - use a hash value of the cache key
    - `false` - don't use a hash valueo f the cache key
  - `hashFn` - optional, a custom callback to generate the hash from the cache key, which is passed in as a string
    - i.e. `function customHashFn(key) { return hash(key); }`

If no `hashFn` is provided, then [farmhash] is used if it's available, otherwise hashing is turned off.

### [`clearProfileData()`](#clearprofiledata)

Clear profiling data

### [`clearCache()`](#clearcache)

Clear caching data

### [`cacheEntries()`](#cacheentries)

Get total number of cache entries

### [`cacheHitReport()`](#cachehitreport)

Print out cache entries and number of hits each one has.

<br/>
# <a name="step-by-step"></a>hapi.js step-by-step instructions
* The following is an example hapi.js app with [electrode-react-ssr-caching] module fully integrated

## <a name="ssr-caching"></a>Electrode React SSR Caching

[electrode-react-ssr-caching] module supports profiling React Server Side Rendering time and component caching to help you speed up SSR.

It supports 2 types of caching:

* Simple - Component Props become the cache key. This is useful for cases like Header and Footer where the number of variations of props data is minimal which will make sure the cache size stays small.
* Template - Components Props are first tokenized and then the generated template html is cached. The idea is akin to generating logic-less handlebars template from your React components and then use string replace to process the template with different props. This is useful for cases like displaying Product information in a Carousel where you have millions of products in the repository.

## Instructions

### <a name="hapijs-server"></a>Hapijs Server
* Let's use the [hapi-universal-redux] repo to scaffold our app.
* Create a hapi app using the following:

```bash
git clone https://github.com/luandro/hapi-universal-redux.git hapiApp
cd hapiApp
npm install
```

* Ensure that you have a working app by running the following:

```bash
npm run dev
```

* From your browser, navigate to `http://localhost:8000` to see the default web page

### <a name="ssr-caching"></a>Electrode React SSR Caching Install
* Install the [electrode-react-ssr-caching] module with the following:

```bash
npm install --save electrode-react-ssr-caching
```

* Import SSRCaching in `hapiApp/src/server.js`

```js
import SSRCaching from "electrode-react-ssr-caching";
```

### *** Important Notes ***
* Make sure the `electrode-react-ssr-caching` module is imported first followed by the imports of `react` and `react-dom` module.
* SSR caching will not work if the ordering is changed since caching module has to have a chance to patch react's code first.
* If you are importing `electrode-react-ssr-caching`, `react` and `react-dom` in the same file, make sure
you are using all `require` or all `import`. Found that SSR caching was NOT working if, `electrode-react-ssr-caching`
is `require`d first and then `react` and `react-dom` is imported.

* Enable caching by adding the configuration code in `hapiApp/src/server.js`

```js
const cacheConfig = {
  components: {
    SSRCachingTemplateType: {
      strategy: "template",
      enable: true
    },
    SSRCachingSimpleType: {
      strategy: "simple",
      enable: true
    }
  }
};

SSRCaching.enableCaching();
SSRCaching.setCachingConfig(cacheConfig);
```

### <a name="ssr-demo-code"></a>SSR Demo Code
* In order to test Server Side Rendering functionality, we need to add a few files:

* For simple strategy, add the following:

`hapiApp/src/components/SSRCachingSimpleType.js`

```js
import React from "react";
import {connect} from "react-redux";

class SSRCachingSimpleTypeWrapper extends React.Component {
  render() {
    const count = this.props.count;

    var elements = [];

	for (var i = 0; i < count; i++) {
      elements.push(<SSRCachingSimpleType key={i} navEntry={"NavEntry" + i} />);
	}

	return (
      <div>
        {elements}
      </div>
    );
  }
}

class SSRCachingSimpleType extends React.Component {
  render() {
    return (
      <div>
	    <p>{this.props.navEntry}</p>
	  </div>
    );
  }
}

const mapStateToProps = (state) => ({
    count: state.count
});

export default connect(
  mapStateToProps
)(SSRCachingSimpleTypeWrapper);
```

* For Template strategy, add the following:

`hapiApp/src/components/SSRCachingTemplateType.js`

```js
import React from "react";
import { connect } from "react-redux";

class SSRCachingTemplateTypeWrapper extends React.Component {
  render() {
    const count = this.props.count;
    var elements = [];

    for(var i = 0; i < count; i++) {
      elements.push(<SSRCachingTemplateType key={i} name={"name"+i} title={"title"+i} rating={"rating"+i}/>);
    }

    return (
      <div>
        { elements }
      </div>
    );
  }
}

class SSRCachingTemplateType extends React.Component {
  render() {
    return (
      <div>
        <p>{this.props.name} and {this.props.title} and {this.props.rating}</p>
      </div>
    );
  }
}

const mapStateToProps = (state) => ({
  count: state.count
})

export default connect(
  mapStateToProps
)(SSRCachingTemplateTypeWrapper);
```

* Add the routes to our new components. Replace the contents of `hapiApp/src/routes.js` with the following:

```js
import React from 'react';
import { Router, Route } from 'react-router';
import Home from './components/Home';
import SSRCachingTemplateType from "./components/SSRCachingTemplateType";
import SSRCachingSimpleType from "./components/SSRCachingSimpleType";

module.exports = (
  <Router>
    <Route>
      <Route path="/" component={Home} />
	  <Route path="/ssrcachingtemplatetype" component={SSRCachingTemplateType} />
      <Route path="/ssrcachingsimpletype" component={SSRCachingSimpleType} />
    </Route>
  </Router>
);
```

* Wire up the home page with our new routes. Replace the contents of `hapiApp/src/components/Home.js` with the following:

```js
import React from "react";

export default class Home extends React.Component {
  render() {
    return (
      <div>
        <h1>Hello <a href="https://github.com/electrode-io">Electrode</a></h1>
        <h2>Demonstration Components</h2>
        <ul>
          <li className="ssr simple">
            <a href="/ssrcachingsimpletype">
              SSR Caching - Simple
            </a>
            <p>Component Props become the cache key. This is useful for cases like Header and Footer where the number
            of variations of props data is minimal which will make sure the cache size stays small.</p>
          </li>
          <li className="ssr caching">
            <a href="/ssrcachingtemplatetype">
              SSR Caching- Template Type
            </a>
            <p>Components Props are first tokenized and then the generated template html is cached. The idea is akin to
            generating logic-less handlebars template from your React components and then use string replace to process
            the template with different props. This is useful for cases like displaying Product information in a
            Carousel where you have millions of products in the repository.</p>
          </li>
        </ul>
	  </div>
    );
  }
}
```

### Redux Configuration

* From `hapiApp/src/server.js` replace the line:

```
const store = configureStore();
```

with:

```
const store = configureStore({count: 100});
```

* Replace the contents of `hapiApp/src/reducers/index.js` with the following:

```js
import { combineReducers } from 'redux';
import { routerReducer } from 'react-router-redux'

const rootReducer = combineReducers({
  routing: routerReducer,
  count: (s=100, a) => s
});

export default rootReducer;
```

* Run the server:

```bash
npm run production
```

* Navigate to the url and port number displayed in the terminal, both links for for Simple and Template Type should return a list of 100 items

### *** Important Notes ***
* SSR caching of components only works in PRODUCTION mode, since the props(which are read only) are mutated for caching purposes and mutating of props is not allowed in development mode by react.

* To read more, go to [electrode-react-ssr-caching]

[electrode-react-ssr-caching]: https://github.com/electrode-io/electrode-react-ssr-caching
[hapi-universal-redux]: https://github.com/luandro/hapi-universal-redux
[Sasha Aickin's talk]: https://www.youtube.com/watch?v=PnpfGy7q96U
[farmhash]: https://github.com/google/farmhash