---
title:  "Explore"
permalink: docs/explore.html
toplevel: "Getting Started: Quick Guide"
---

<h5>Explore</h5>

<p class="body-text">What does generate-electrode give you? Let's begin by navigating to <'your-awesome-app'>/client/components/home.jsx: </p>

{% raw  %}
```
  client
    |_components
      |_home.jsx
```
{% endraw %}

<p class="body-text">
  <a href="https://facebook.github.io/react/index.html">React</a> is a JavaScript library for building user interfaces. A simplified way to look at it is that it can be used as the V in an MV* application. It was created by Facebook and is being actively developed.</p>

  <p>Building with React lets developers create a modular and reusable component architecture. We can reuse the business logic in existing models and controllers because it only provides the View layer. The components you write are self-contained, which aids developers in reasoning what a component does directly by reading the source. Finally, it is ideally suited to Universal JavaScript (previously called Isomorphic JavaScript), the practice of sharing code between Server and Client.</p>

Next, navigate to <'your-awesome-app'>/client/styles/base.css:</p>

{% raw  %}
```
client
  |_base.css
```
{% endraw %}

We will use [CSS Modules](https://github.com/css-modules/css-modules): a CSS file in which all class names and animation names are scoped locally by default. At WalmartLabs this helps us tackle big scale style issues by fixing the issue of the global scope in CSS.

<p>Let's peer inside of our client/app.jsx to get a better understanding of the relationship between the client and the server: <'your-awesome-app'>/client/app.jsx:</p>

{% raw  %}
```
client
  |_app.jsx
```
{% endraw %}

<p class="body-text">Below is the information you need to know about what the app.jsx is doing. We've broken it down, with links on where you can learn even more: </p>

```javascript
  import React from "react";
  import { routes } from "./routes";
  import { Router } from "react-router";
```
  <p>Any real world web application needs to be able to handle different routes serving different content, so how do we handle the concept of routing in the Electrode platform? The library chosen to take care of this for us is <a href="https://github.com/reactjs/react-router/tree/master/docs" class="doc-links">react-router</a>.</p>

  <p>Why <a href="https://github.com/reactjs/react-router/tree/master/docs" class="doc-links">react-router</a>? The project is mature, well documented and integrates well within the Electrode tech stack.</p>

```javascript
  import { Resolver } from "react-resolver";
```

  <p><a href="http://ericclemmons.com/react-resolver/" class="doc-links">React-Resolver</a> lets you define data requirements per component and will handle the nested, async rendering on both the server and client for you. This approach matches the Electrode methodology of keeping definitions of what a component needs within the component (), and also allows us to write universal javascript applications in a non-blocking way. This solves our frequent need for pages that are rendered on the server.</p>

```javascript
  import { createHistory } from "history";
  import "./styles/base.css";
```

  <p><a href="https://github.com/mjackson/history" class="doc-links">History</a> is a JavaScript library that lets you easily manage session history anywhere JavaScript runs and abstracts away the differences in various environments.</p>

```javascript
    window.webappStart = () => {
      Resolver.render(
        () => <Router history={createHistory()}>{routes}</Router>,
        document.querySelector(".js-content")
      );
    };
```

<p class="body-text">If you have a universal application and server side rendering, <a href="http://ericclemmons.com/react-resolver/docs/getting-started/ServerRendering.html" class="doc-links">react-resolver</a> handles bootstrapping server-rendered markup via Resolver.render instead of React.render.</p>

<p>We will be sharing our routes between server and client so obviously we only want to define them in one place, in your <'your-awesome-app'>/client/routes.jsx:</p>

{% raw  %}
```
client
  |_routes.jsx
```
{% endraw %}

<p>In your <'your-awesome-app'>/config we are leveraging one of most important stand alone modules: <a href="#/link-to-internal-confippet-doc" class="doc-links">electrode-confippet</a>.</p>

<p>Confippet is a versatile utility for managing your NodeJS application configuration. Its goal is customization and extensibility, but offers a <a href="https://github.com/electrode-io/electrode-confippet" class="doc-links">preset config</a> out of the box.</p>

<p>We use this to keep your environment specific configurations manageable. Once you have your config files setup according to the configuration files setup, you can simply pass the config object to electrode server.</p>

{% raw  %}
```
config
  |_default.json
  |_development.json
  |_production.json
```
{% endraw %}

<p>Let's checkout your <'your-awesome-app'>/server</p>

{% raw  %}
```
server
  |_plugins
    |_webapp
      |_index.html
    |_index.js
  |_views
    |_index-view.jsx
  |_index.js
```
{% endraw %}

<p>You are now using <a href="#" class="doc-links">Electrode-Server</a>, a NodeJS module that allows you to start up a Hapi server with a single function call, but gives you a lot of flexibility through configurations. This is the baseline functionality of a Hapi web server that you can extend via configuration.</p>

<p>Before we move on, we should inspect a critical file, <'your-awesome-app'>/server/plugins/webapp/index.html. This is where the server side "magic" happens. By magic, of course we mean the benefits of using the generate-electrode + server side rendering.</p>

{% raw  %}
```
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>{{PAGE_TITLE}}</title>
      {{WEBAPP_BUNDLES}}
      {{PREFETCH_BUNDLES}}
    </head>
    <body>
      <div class="js-content">{{SSR_CONTENT}}</div>
      <script>if (window.webappStart) webappStart();</script>
    </body>
  </html>
```
{% endraw %}

<p>All of your content will be served into an HTML string and placed in this unassuming piece of code: </p>

{% raw  %}
```
  <div class="js-content">{{SSR_CONTENT}}</div>
```
{% endraw %}

<p>This includes <a href="" class="doc-links">React</a> components and Redux. To achieve this, the Electrode team has created another powerful module here to optimize performance for your out-the-box Universal app:</p>
<p><a href="https://github.com/electrode-io/redux-router-engine" class="doc-links">Electrode-Router-Resolver-Engine</a> which takes React routes and requests and returns HTML to be rendered by electrode-react-webapp. We have found this to be the best tool for dealing with <a href="https://github.com/electrode-io/redux-router-engine" class="doc-links">redux asynchronous actions</a>.</p>

<p>Next, we should discuss the <'your-awesome-app'>/.babelrc:</p>

```
.babelrc
```

<p>This is where we extend our electrode-archetype-react-app babel <a href="https://babeljs.io/docs/usage/babelrc/" class="doc-links">configuration</a> to allow us to use the <a href="https://babeljs.io/docs/plugins/preset-es2015/" class="doc-links">presets</a> (ES6, React) and any plugins or projects that need additional Babel settings.</p>

<p>Following, we have the <'your-awesome-app'>/isomorphic-loader-config.json:</p>

```
.isomorphic-loader-config.json
```
<p>This <a href="https://github.com/jchip/isomorphic-loader" class="doc-links">Webpack loader</a> and tools to make NodeJS require understands files such as images when you are doing server side rendering. It contains three pieces: a Webpack loader, Webpack plugin and a library for your NodeJS app.</p>

<p>With the generator-electrode, we've created a dynamic and performant full stack Electrode app in under five minutes, using some of our favorites technologies, like <a href="https://facebook.github.io/react/index.html" target="_blank">React</a> and <a href="http://hapijs.com/" target="_blank">Hapi</a>. Let's explore and personalize this web application in our next section, <a href="#" class="doc-links">Getting Started: Build More</a>.</p>
