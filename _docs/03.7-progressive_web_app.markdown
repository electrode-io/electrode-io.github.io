---
title:  "Build a Progressive Web App"
permalink: docs/service_workers.html
toplevel: "Getting Started: Intermediate"
---

“A Progressive Web App uses modern web capabilities to deliver an app-like user experience.” – [Progressive Web Apps](https://developers.google.com/web/progressive-web-apps/)

PWA are incredibly powerful and provide functionalities like Offline first, Push notifications, Background sync and Add to home screen.

In this section, we are going to build a PWA with content caching, push notifications and an option for the user to save your web app to their home screen.

PWA are purely based on [Service Workers](https://developers.google.com/web/fundamentals/getting-started/primers/service-workers) and their ability to work independently in the background without interfering your web app's life cycle.


## Getting Started

### Generate Electrode App

We will start from scratch with a new app:

```bash
$ npm install -g yo generator-electrode
$ mkdir electrode-pwa
$ cd electrode-pwa
$ yo electrode
# ... answer questions and wait for app to be generated and npm install completed ...
```

Quickly run `gulp dev` and navigate to `http://localhost:3000` to make sure app is working.

### Prerequisites
1. We need certain API keys for push notifications.
To generate these values, visit [Firebase](https://console.firebase.google.com) and create a new project.  
Click on the setting icons and open `Project settings`.  
Navigate to the `CLOUD MESSAGING` tab and note down your `Server key` and the `Sender ID`.  

2. Create a `images` folder inside the `client` directory and add the Electrode [logo 192x192](https://github.com/electrode-io/electrode-boilerplate-universal-react-node/blob/master/client/images/logo-192x192.png) and [logo 72x72](https://github.com/electrode-io/electrode-boilerplate-universal-react-node/blob/master/client/images/logo-72x72.png) to it. We will be using this logo for `Add to Homescreen` banner and for `Push Notifications`.

### Adding a Service Worker

Generating a service worker in an electrode app is as simple as adding a config file. Navigate to `electrode-pwa/config` and create a new `sw-config.js`:

```javascript
module.exports = {
  cacheId: "electrode",
  cache: {
    runtimeCaching: [{
      handler: "fastest",
      urlPattern: /\/$/
    }],
    staticFileGlobs: ['dist/**/*']
  },
  stripPrefix: "dist/js/",
  manifest: {
    background: "#FFFFFF",
    logo: "./images/logo-192x192.png",
    title: "Electrode Progressive App",
    short_name: "EPA",
    theme_color: "#FFFFFF"
  }
};
```

We achieved couple of things here:

1. `Offline First` with the cache property

Precache your static assets generated by webpack using the staticFileGlobs property. Or use the runtimeCaching property to cache specific react routes in from your routes.jsx

1. `Add to Home` with the manifest property

After visiting your website, users will get a prompt (if the user has visited your site at least twice, with at least five minutes between visits.) to add your application to their homescreen. `manifest` gives you control over how your web app is installed on user's home screen with `short_name`, `title` and `logo` properties.

Build the app and start the server with

```bash
$ gulp build && gulp server
```
##### Note: Service worker currently does not work with webpack dev server. You need to build first and then run the server.

Navigate to `http://localhost:3000`, open `Developer tools` and click on the `Application` tab. You should see your `Service Worker` activated and running!

![screenshot][screenshot]

Go ahead and click on the `Offline` checkbox in the Developer tools. Terminate your server. Refresh your web page.

##### `Add to Homescreen` banner will pop up only on Android devices with Chrome 42+. To simulate the banner on your desktop Chrome, navigate to `Developer tools` -> `Applications` -> `Manifest` and click on `Add to homescreen`.

### Push notifications
The [Push API](https://developer.mozilla.org/en-US/docs/Web/API/Push_API) requires a registered service worker so it can send notifications in the background when the web application isn't running.  
We already have our Service Worker generated with the help of `sw-config.js`. We only need to add a `Push` event to it.  
Create a new file `sw.js` inside the `client` directory and add the following to it:

```javascript
/* eslint-env serviceworker */

import icon from "./images/logo-192x192.png";
import badge from "./images/logo-72x72.png";

self.addEventListener("push", (event) => {
  const title = "It worked!";
  const options = {
    body: "Great job sending that push notification!",
    tag: "electrode-push-notification-test",
    icon,
    badge
  };
  event.waitUntil(
    self.registration.showNotification(title, options)
  );
});
```
Check out the [Adding Push Notifications to a Web App](https://developers.google.com/web/fundamentals/getting-started/codelabs/push-notifications/) Codelab provided by Google for an in-depth guide on how push notifications and service workers work together.


Now we need to add this file to our webpack bundle by referencing it in the cache property of `sw-config.js`:

```javascript
module.exports = {
  cache: {
    importScripts: ['./sw.js']
  }
}
```

Our service worker with `push` event is ready to be registered on the browser. To register, create a new file `register-service-worker` inside the `client` directory:

```javascript
/* eslint-env browser */
/* eslint-disable no-console */

module.exports = () => {
  // Exit early if the navigator isn't available
  if (typeof navigator === "undefined") {
    return;
  }
  // Feature check if service workers are supported.
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("sw.js", { scope: "./" })
      // Service worker registration was successful
      .then((registration) => {
        // The updatefound event is dispatched when the installing
        // worker changes. This new worker will potentially become
        // the active worker if the install process completes.
        registration.onupdatefound = function () {
          const installingWorker = registration.installing;
          // Listen for state changes on the installing worker so
          // we know when it has completed.
          installingWorker.onstatechange = function () {
            switch (installingWorker.state) {
            case "installing":
              console.log("Installing a new service worker...");
              break;
            case "installed":
              console.log(navigator.serviceWorker.controller);
              // We check the active controller which tells us if
              // new content is available, or the current service worker
              // is up to date (?)
              // TODO: Figure out why this is the case
              if (navigator.serviceWorker.controller) {
                console.log("New or updated content is available, refresh!");
              } else {
                console.log("Content is now available offline!");
              }
              break;
            case "activating":
              console.log("Activating a service worker...");
              break;
            case "activated":
              console.log("Successfully activated service worker.");
              break;
            case "redundant":
              console.log("Service worker has become redundant");
              break;
            }
          };
        };
      })
      // Service worker registration failed
      .catch((err) => {
        console.log("Service worker registration failed: ", err);
      });
  }
};
```

Now we have a registered service worker installed, activated and ready to accept `push` from the server.  
But before we can `push` we need to `request permissions` from the user and `subscribe` them to the notifications.

Navigate to `client/components/home.jsx` and add the following code inside the `class Home`:

```javascript
constructor() {
    super();
    this.state = {
      // Whether ServiceWorkers are supported
      supported: false,
      // Did something fail?
      error: null,
      // Waiting on the service worker to be ready
      loading: true,
      // Whether we"ve got a push notification subscription
      subscribed: false,
      // The actual subscription itself
      subscription: null,
      title: "",
      body: ""
    };
    this.sendNotification = this.sendNotification.bind(this);
    this.handleInputChange = this.handleInputChange.bind(this);
    this.subscribe = this.subscribe.bind(this);
  }

  componentDidMount() {
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.ready.then((registration) => {
        // Check for any existing subscriptions
        registration.pushManager.getSubscription().then((subscription) => {
          // No current subscription, let the user subscribe
          if (!subscription) {
            this.setState({
              loading: false,
              subscribed: false,
              supported: true
            });
          } else {
            this.setState({
              subscription,
              subscribed: true,
              loading: false,
              supported: true
            });
          }
        })
        .catch((error) => {
          this.setState({
            loading: false,
            error
          });
        });
      })
      .catch((error) => {
        this.setState({
          loading: false,
          error
        });
      });
    } else {
      // ServiceWorkers are not supported, let the user know.
      this.setState({
        loading: false,
        supported: false
      });
    }
  }

  subscribe() {
    navigator.serviceWorker.ready.then((registration) => {
      registration.pushManager.subscribe({ userVisibleOnly: true })
        .then((subscription) => {
          this.setState({
            subscription,
            subscribed: true
          });
        })
        .catch((error) => {
          this.setState({ error });
        });
    });
  }

  handleInputChange(event) {
    this.setState({
      [event.target.name]: event.target.value
    });
  }

  sendNotification() {
    const { title, body } = this.state;
    const options = { body, icon, badge };
    navigator.serviceWorker.ready.then((registration) => {
      registration.showNotification(title, options);
    });
  }
```

`navigator.serviceWorker.ready` is a Promise that will resolve once a service worker is registered, and it returns a reference to the active [ServiceWorkerRegistration](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration). The showNotification() method of the ServiceWorkerRegistration interface creates a notification and returns a Promise that resolves to a [NotificationEvent](https://developer.mozilla.org/en-US/docs/Web/API/NotificationEvent).

Change the `render()` of `class Home` to look like this:

```javascript
render() {
  const props = this.props;
  const {checked, value} = props;
  const {
    error,
    loading,
    supported,
    subscribed,
    subscription
  } = this.state;

  if (!loading && !supported) {
    return (
      <div>Sorry, service workers are not supported in this browser.</div>
    );
  }

  if (error) {
    return (
      <div>
        Woops! Looks like there was an error:
        <span style={{ fontFamily: "monospace", color: "red" }}>
          {error.name}: {error.message}
          </span>
      </div>
    );
  }

  if (loading) {
    return (
      <div>
        Checking push notification subscription status...
      </div>
    );
  }

  if (!subscribed) {
    return (
      <div>
        Click below to subscribe to push notifications
        <button onClick={this.subscribe}>Subscribe</button>
      </div>
    );
  }

  const API_KEY = "YOUR API KEY";
  const GCM_ENDPOINT = "https://android.googleapis.com/gcm/send";
  const endpointSections = subscription.endpoint.split("/");
  const subscriptionId = endpointSections[endpointSections.length - 1];

  const curlCommand = `curl --header "Authorization: key=${API_KEY}"
  --header Content-Type:"application/json" ${GCM_ENDPOINT} -d
  "{\\"registration_ids\\":[\\"${subscriptionId}\\"]}"`;

  return (
    <div>
      <h1>Hello <a href={"https://github.com/electrode-io"}>{"Electrode"}</a></h1>
      <div>
        <h2>Managing States with Redux</h2>
        <label>
          <input onChange={props.onChangeCheck} type={"checkbox"} checked={checked}/>
          Checkbox
        </label>
        <div>
          <button type={"button"} onClick={props.onDecrease}>-</button>
          &nbsp;{value}&nbsp;
          <button type={"button"} onClick={props.onIncrease}>+</button>
        </div>
      </div>

      <br/>
      <h2>Push Notifications with Service Workers</h2>
      Use the form below to define the parameters for a push notification.
      Click the send button to trigger the notification itself.
      <label htmlFor="title">Title</label>
      <input
        onChange={this.handleInputChange}
        name="title"
      />
      <label htmlFor="body">Body</label>
      <input
        onChange={this.handleInputChange}
        name="body"
      />
      <br/>
      <button onClick={this.sendNotification}>Send</button>
      <h3>Subscription Endpoint</h3>
      <code>
        {this.state.subscription.endpoint}
      </code>
      <h3>Curl Command</h3>
      <code>
        {curlCommand}
      </code>
    </div>
  );
}
```
Make sure you update the `API_KEY` with the one you previously generated in [Prerequisites](#prerequisites).
We also need to update `sw-config.js` with the `sender_id`, so the final `sw-config.js` should look like:

```javascript
module.exports = {
  cacheId: "electrode",
  cache: {
    runtimeCaching: [{
      handler: "fastest",
      urlPattern: /\/$/
    }],
    staticFileGlobs: ['dist/**/*']
  },
  stripPrefix: "dist/js/",
  manifest: {
    background: "#FFFFFF",
    logo: "./images/logo-192x192.png",
    title: "Electrode Progressive App",
    short_name: "EPA",
    theme_color: "#FFFFFF",
    gcm_sender_id: "YOUR SENDER ID"
  }
};
```

Rebuild your app and run the server with

```bash
$ gulp build && gulp server
```

With all the code in place, we are ready to see push notifications in action.

Navigate to `http://localhost:3000`. Accept the permission for subscribing and you will see a curl command rendered on the page. You can either run the curl command from terminal to see the push notification or fill out the form and click on the `Send` button to trigger it!

[screenshot]: https://cloud.githubusercontent.com/assets/4782871/20856268/dab6930c-b8bf-11e6-92f7-1dae1e53b4d2.png
